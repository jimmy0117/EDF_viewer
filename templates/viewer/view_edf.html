<!DOCTYPE html>
<html lang="zh-tw">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ edf_file.title }} - EDF æª¢è¦–å¹³å°</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow-x: hidden; }
        .navbar { margin-bottom: 0; }
        .main-container { display: flex; height: calc(100vh - 56px); }
        .sidebar {
            width: 260px;
            background-color: #2c3e50;
            color: white;
            border-right: 1px solid #34495e;
            overflow-y: auto;
            padding: 15px;
        }
        .viewer-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; background-color: #ecf0f1; }
        .hypnogram-container { height: 120px; border-bottom: 2px solid #34495e; background-color: #fff; }
        .signals-container { flex: 1; overflow-y: auto; background-color: #fff; padding: 10px; }
        .signal-plot {
            height: 150px;
            min-height: 80px;
            border: 1px solid #bdc3c7;
            margin-bottom: 10px;
            position: relative;
            background-color: #fff;
            border-radius: 4px;
        }
        .signal-title {
            text-align: center;
            font-weight: 700;
            color: #2c3e50;
            margin: 4px 0 2px;
        }
        /* æ–°å¢æ‹–æ›³æŠŠæ‰‹æ¨£å¼ */
        .resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            /* right: 6px; -> ç§»åˆ°ä¸­å¤® */
            left: 50%;
            bottom: 6px;
            transform: translateX(-50%);
            cursor: ns-resize;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-radius: 3px;
            box-shadow: 0 0 4px rgba(0,0,0,0.2);
            opacity: 0.85;
        }
        .signal-label {
            position: absolute;
            left: 10px;
            top: 5px;
            font-weight: bold;
            font-size: 13px;
            background-color: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            z-index: 10;
        }
        .controls {
            height: 70px;
            background-color: #34495e;
            border-top: 2px solid #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        }
        .signal-list-item {
            padding: 10px;
            margin-bottom: 8px;
            background-color: #3498db;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }
        .signal-list-item:hover { background-color: #2980b9; transform: translateX(5px); }
        .signal-list-item.active { background-color: #2980b9; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
        .signal-list-item.inactive { background-color: #7f8c8d; opacity: 0.6; }
        .time-info { font-size: 16px; font-weight: bold; color: white; }
        .btn-control {
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 5px;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-control:hover { transform: scale(1.05); }
        .btn-primary-control { background-color: #3498db; }
        .btn-primary-control:hover { background-color: #2980b9; }
        .btn-secondary-control { background-color: #95a5a6; }
        .btn-secondary-control:hover { background-color: #7f8c8d; }
        .sidebar h6 { color: #ecf0f1; border-bottom: 2px solid #3498db; padding-bottom: 8px; margin-bottom: 15px; }
        
        /* éš±è— number input çš„ä¸Šä¸‹ç®­é ­ */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        
        /* ç¡çœ éšæ®µåœ–ä¾‹æ¨£å¼ */
        .stage-legend {
            margin-top: 15px;
        }
        .stage-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.3s;
        }
        .stage-item:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }
        .stage-color {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid #555;
        }
        .stage-name {
            font-size: 13px;
        }
    </style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="{% url 'viewer:index' %}">EDF æª¢è¦–å¹³å°</a>
        <div class="navbar-text text-white">
            <strong>{{ edf_file.title }}</strong> | æ™‚é•·: {{ edf_file.duration|floatformat:1 }}s
        </div>
    </div>
</nav>

<div class="main-container">
    <div class="sidebar">
        <h6>ä¿¡è™Ÿåˆ—è¡¨ ({{ signals.count }})</h6>
        <div id="signal-list">
            {% for signal in signals %}
            <div class="signal-list-item active" data-signal-id="{{ signal.id }}" data-signal-label="{{ signal.signal_label }}">
                <div><strong>{{ signal.signal_label }}</strong></div>
                <small>{{ signal.units|default:"N/A" }} | {{ signal.sampling_rate|floatformat:0 }} Hz</small>
            </div>
            {% endfor %}
        </div>
        <hr style="border-color: #7f8c8d;">
        <div>
            <h6>æª”æ¡ˆè³‡è¨Š</h6>
            <small>
                æ‚£è€…: {{ edf_file.patient_name|default:"æœªçŸ¥" }}<br>
                éŒ„è£½: {{ edf_file.recording_date|date:"Y-m-d H:i"|default:"æœªçŸ¥" }}<br>
                ä¿¡è™Ÿæ•¸: {{ edf_file.num_signals }}
            </small>
        </div>
        <hr style="border-color: #7f8c8d;">
        <div class="stage-legend">
            <h6>ç¡çœ éšæ®µ</h6>
            <div class="stage-item">
                <div class="stage-color" style="background-color: #FFD700;"></div>
                <span class="stage-name">W - æ¸…é†’</span>
            </div>
            <div class="stage-item">
                <div class="stage-color" style="background-color: #FF6347;"></div>
                <span class="stage-name">REM - å¿«é€Ÿå‹•çœ¼</span>
            </div>
            <div class="stage-item">
                <div class="stage-color" style="background-color: #87CEEB;"></div>
                <span class="stage-name">N1 - æ·ºç¡</span>
            </div>
            <div class="stage-item">
                <div class="stage-color" style="background-color: #4169E1;"></div>
                <span class="stage-name">N2 - ç¡çœ </span>
            </div>
            <div class="stage-item">
                <div class="stage-color" style="background-color: #00008B;"></div>
                <span class="stage-name">N3 - æ·±ç¡</span>
            </div>
        </div>
    </div>
    
    <div class="viewer-area" data-has-hypnogram="{{ edf_file.hypnogram_file|yesno:'1,0' }}">
        <div class="hypnogram-container" id="hypnogram"></div>
        <div class="signals-container" id="signals-container">
            <div class="text-center text-muted py-5">
                <div class="spinner-border" role="status"></div>
                <p class="mt-3">è¼‰å…¥ä¿¡è™Ÿæ•¸æ“šä¸­...</p>
            </div>
        </div>
        <div class="controls">
            <button class="btn-control btn-secondary-control" id="btn-start">â® èµ·å§‹</button>
            <button class="btn-control btn-primary-control" id="btn-prev">â—€ ä¸Šé </button>
            <span class="time-info">
                é–‹å§‹: <input type="number" id="current-time" value="0.0" min="0" max="{{ edf_file.duration|floatformat:1 }}" step="1" style="width: 70px; text-align: center; border: 2px solid #3498db; border-radius: 4px; padding: 4px; background: #2c3e50; color: white; font-weight: bold;">s
            </span>
            <span class="time-info">
                çµæŸ: <input type="number" id="end-time" value="30.0" min="0" max="{{ edf_file.duration|floatformat:1 }}" step="1" style="width: 70px; text-align: center; border: 2px solid #3498db; border-radius: 4px; padding: 4px; background: #2c3e50; color: white; font-weight: bold;">s
            </span>
            <span class="time-info">/ <span id="total-time">{{ edf_file.duration|floatformat:1 }}</span>s</span>
            <button class="btn-control btn-primary-control" id="btn-next">ä¸‹é  â–¶</button>
            <button class="btn-control btn-secondary-control" id="btn-end">çµæŸ â­</button>
            <select class="form-select form-select-sm" id="window-size" style="width: 130px;">
                <option value="10">10 ç§’</option>
                <option value="30" selected>30 ç§’</option>
                <option value="60">60 ç§’</option>
                <option value="120">120 ç§’</option>
            </select>
            <button class="btn-control btn-primary-control" id="btn-refresh">ğŸ”„ é‡æ–°è¼‰å…¥</button>
        </div>
    </div>
</div>

<script>
const totalDuration = {{ edf_file.duration }};
let currentTime = 0;
let windowSize = 30;
const signalCache = {};
const inFlight = new Set();
const activeSignals = new Set();
const signalHeights = {};
const hasHypnogram = document.querySelector('.viewer-area').dataset.hasHypnogram === '1';
const CHUNK_SIZE = 300; // æœ€å¤§å–®æ¬¡è¼‰å…¥ 300 ç§’çš„æ•¸æ“š

// å¿«é€ŸæŸ¥è©¢ä¿¡è™Ÿå…ƒæ•¸æ“š
const signalMetadata = {};
{% for signal in signals %}
signalMetadata[{{ signal.id }}] = {
    label: '{{ signal.signal_label }}',
    units: '{{ signal.units }}',
    sampling_rate: {{ signal.sampling_rate }}
};
{% endfor %}

const STAGE_COLORS = {
    'W': '#FFD700',
    'N1': '#87CEEB',
    'N2': '#4169E1',
    'N3': '#00008B',
    'REM': '#FF6347',
    'unknown': '#CCC'
};

// åˆå§‹åŒ–æ´»å‹•ä¿¡è™Ÿ
document.querySelectorAll('.signal-list-item').forEach(item => {
    activeSignals.add(parseInt(item.dataset.signalId));
});

// ä¿¡è™Ÿåˆ—è¡¨é»æ“Šäº‹ä»¶
document.querySelectorAll('.signal-list-item').forEach(item => {
    item.addEventListener('click', function() {
        const signalId = parseInt(this.dataset.signalId);
        
        if (activeSignals.has(signalId)) {
            activeSignals.delete(signalId);
            this.classList.remove('active');
            this.classList.add('inactive');
        } else {
            activeSignals.add(signalId);
            this.classList.remove('inactive');
            this.classList.add('active');
        }
        renderSignals();
    });
});

// è¼‰å…¥æ‰€æœ‰ä¿¡è™Ÿæ•¸æ“š
async function loadAllSignals() {
    const signals = [{% for signal in signals %}{{ signal.id }}{% if not forloop.last %},{% endif %}{% endfor %}];
    
    for (const signalId of signals) {
        try {
            const response = await fetch(`/signal/${signalId}/data/`);
            const data = await response.json();
            if (!data.error) {
                signalData[signalId] = data;
            }
        } catch (error) {
            console.error(`è¼‰å…¥ä¿¡è™Ÿ ${signalId} å¤±æ•—:`, error);
        }
    }
    
    renderHypnogram();
    renderSignals();
}

// æ¸²æŸ“ Hypnogram
async function renderHypnogram() {
    if (!hasHypnogram) {
        Plotly.newPlot('hypnogram', [], { title: { text: 'Hypnogram (ç„¡è³‡æ–™)' }, height: 120 }, { displayModeBar: false });
        return;
    }

    try {
        const res = await fetch(`/edf/{{ edf_file.pk }}/hypnogram/`);
        if (!res.ok) throw new Error(await res.text());
        const json = await res.json();

        if (json.error) {
            Plotly.newPlot('hypnogram', [], { title: { text: `Hypnogram (è®€å–å¤±æ•—: ${json.error})` }, height: 120 }, { displayModeBar: false });
            return;
        }

        const annotations = json.data || [];
        
        // ç”¢ç”Ÿè‰²å¡Š (shapes) - æ¯å€‹ annotation ä¸€å€‹è‰²å¡Š
        const shapes = annotations.map(ann => ({
            type: 'rect',
            x0: ann.onset,
            x1: ann.onset + ann.duration,
            y0: -0.5,
            y1: 0.5,
            fillcolor: STAGE_COLORS[ann.stage] || STAGE_COLORS['unknown'],
            opacity: 0.8,
            line: { width: 1, color: '#333' },
        }));

        const layout = {
            title: { text: 'Hypnogram', font: { size: 14 } },
            xaxis: { 
                range: [currentTime, Math.min(currentTime + windowSize, totalDuration)],  // èˆ‡ä¿¡è™ŸåŒæ­¥
                title: 'æ™‚é–“ (ç§’)',
                gridcolor: '#ecf0f1'
            },
            yaxis: { 
                range: [-1, 1],
                tickvals: [],
                showticklabels: false,
            },
            height: 120,
            margin: { l: 60, r: 30, t: 40, b: 40 },
            shapes: shapes,
            plot_bgcolor: '#fff',
            paper_bgcolor: '#fff'
        };

        Plotly.newPlot('hypnogram', [], layout, { displayModeBar: false });

    } catch (err) {
        console.error('Hypnogram error:', err);
        Plotly.newPlot('hypnogram', [], { title: { text: `Hypnogram (è®€å–å¤±æ•—: ${err.message})` }, height: 120 }, { displayModeBar: false });
    }
}

// è¼‰å…¥ä¿¡è™Ÿè¦–çª—æ•¸æ“š - æ”¹é€²ç‰ˆæœ¬ï¼Œæ”¯æ´æ›´å¤§ç¯„åœ
async function loadSignalWindow(signalId) {
    const windowKey = `${currentTime}-${windowSize}`;
    const cache = signalCache[signalId];

    if (cache && cache.windowKey === windowKey) return;
    if (inFlight.has(`${signalId}-${windowKey}`)) return;

    inFlight.add(`${signalId}-${windowKey}`);
    
    try {
        const endTime = currentTime + windowSize;
        const metadata = signalMetadata[signalId];
        
        let allData = [];
        
        // å¦‚æœè¦–çª—å¾ˆå¤§ï¼Œåˆ†æ‰¹è¼‰å…¥
        if (windowSize > CHUNK_SIZE) {
            const chunkCount = Math.ceil(windowSize / CHUNK_SIZE);
            
            for (let i = 0; i < chunkCount; i++) {
                const chunkStart = currentTime + (i * CHUNK_SIZE);
                const chunkEnd = Math.min(chunkStart + CHUNK_SIZE, endTime);
                
                try {
                    const res = await fetch(`/signal/${signalId}/data/?start=${chunkStart}&end=${chunkEnd}`);
                    const json = await res.json();
                    
                    if (!json.error && json.data) {
                        allData = allData.concat(json.data);
                    }
                } catch (e) {
                    console.error(`è¼‰å…¥ä¿¡è™Ÿ ${signalId} åˆ†å¡Š ${i+1}/${chunkCount} å¤±æ•—:`, e);
                }
                
                // çµ¦ç€è¦½å™¨ä¸€é»æ™‚é–“è™•ç†
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            if (allData.length > 0) {
                signalCache[signalId] = { 
                    windowKey, 
                    data: allData,
                    sampling_rate: metadata.sampling_rate,
                    signal_label: metadata.label,
                    units: metadata.units
                };
            }
        } else {
            // å°ç¯„åœç›´æ¥è¼‰å…¥
            const res = await fetch(`/signal/${signalId}/data/?start=${currentTime}&end=${endTime}`);
            const json = await res.json();
            if (!json.error) {
                signalCache[signalId] = { windowKey, ...json };
            }
        }
    } catch (e) {
        console.error(e);
    } finally {
        inFlight.delete(`${signalId}-${windowKey}`);
        renderSignals();
    }
}

// æ¸²æŸ“ä¿¡è™Ÿ
function renderSignals() {
    const container = document.getElementById('signals-container');
    container.innerHTML = '';

    if (activeSignals.size === 0) {
        container.innerHTML = '<div class="text-center text-muted py-5"><p>è«‹å¾å·¦å´é¸æ“‡è¦é¡¯ç¤ºçš„ä¿¡è™Ÿ</p></div>';
        return;
    }

    activeSignals.forEach(signalId => {
        const plotDiv = document.createElement('div');
        plotDiv.className = 'signal-plot';
        plotDiv.id = `signal-plot-${signalId}`;
        plotDiv.style.height = `${signalHeights[signalId] || 150}px`;

        const cache = signalCache[signalId];
        const windowKey = `${currentTime}-${windowSize}`;
        const label = (cache && cache.signal_label) ||
            document.querySelector(`[data-signal-id="${signalId}"]`)?.dataset.signalLabel ||
            `Signal ${signalId}`;

        const titleDiv = document.createElement('div');
        titleDiv.className = 'signal-title';
        titleDiv.textContent = label;

        container.appendChild(titleDiv);
        container.appendChild(plotDiv);

        if (!cache || cache.windowKey !== windowKey) {
            plotDiv.innerHTML = '<div class="text-center text-muted py-4">è¼‰å…¥ä¸­...</div>';
            loadSignalWindow(signalId);
            return;
        }

        const { data, sampling_rate, signal_label, units } = cache;
        const timeArray = data.map((_, i) => currentTime + (i / (sampling_rate || 1)));
        const plotHeight = signalHeights[signalId] || 150;

        const trace = {
            x: timeArray,
            y: data,
            type: 'scatter',
            mode: 'lines',
            line: { color: '#2980b9', width: 1.5 },
            name: signal_label
        };

        const layout = {
            xaxis: { range: [currentTime, Math.min(currentTime + windowSize, totalDuration)] },
            yaxis: { title: { text: units || 'N/A', font: { size: 11 } } },
            height: plotHeight,
            margin: { l: 60, r: 30, t: 10, b: 30 },
            showlegend: false
        };

        Plotly.newPlot(plotDiv.id, [trace], layout, { displayModeBar: false, responsive: true });

        // æ–°å¢ï¼šæ‹–æ›³æŠŠæ‰‹
        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        plotDiv.appendChild(handle);
        attachResizeHandle(handle, plotDiv, signalId);
    });
}

// æ–°å¢ï¼šè¨­å®šæ‹–æ›³äº‹ä»¶ä»¥èª¿æ•´é«˜åº¦
function attachResizeHandle(handle, plotDiv, signalId) {
    let startY = 0;
    let startHeight = 0;

    const onMouseMove = (e) => {
        const newHeight = Math.max(80, startHeight + (e.clientY - startY));
        signalHeights[signalId] = newHeight;
        plotDiv.style.height = `${newHeight}px`;
        Plotly.relayout(plotDiv.id, { height: newHeight });
    };

    const onMouseUp = () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
    };

    handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startY = e.clientY;
        startHeight = plotDiv.offsetHeight;
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
}

// æ§åˆ¶æŒ‰éˆ•
document.getElementById('btn-start').addEventListener('click', () => {
    currentTime = 0;
    updateView();
});

document.getElementById('btn-prev').addEventListener('click', () => {
    currentTime = Math.max(0, currentTime - windowSize);
    updateView();
});

document.getElementById('btn-next').addEventListener('click', () => {
    currentTime = Math.min(totalDuration - windowSize, currentTime + windowSize);
    updateView();
});

document.getElementById('btn-end').addEventListener('click', () => {
    currentTime = Math.max(0, totalDuration - windowSize);
    updateView();
});

document.getElementById('window-size').addEventListener('change', (e) => {
    windowSize = parseInt(e.target.value);
    currentTime = Math.min(currentTime, totalDuration - windowSize);
    updateView();
});

document.getElementById('btn-refresh').addEventListener('click', () => {
    signalData = {};
    loadAllSignals();
});

// æ™‚é–“è¼¸å…¥æ¡†äº‹ä»¶ - é–‹å§‹æ™‚é–“
document.getElementById('current-time').addEventListener('change', (e) => {
    const newTime = parseFloat(e.target.value);
    if (!isNaN(newTime) && newTime >= 0 && newTime <= totalDuration) {
        currentTime = Math.min(newTime, totalDuration - windowSize);
        updateTimeInputs();
        updateView();
    } else {
        e.target.value = currentTime.toFixed(1);
    }
});

document.getElementById('current-time').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.target.blur(); // è§¸ç™¼ change äº‹ä»¶
    }
});

// æ™‚é–“è¼¸å…¥æ¡†äº‹ä»¶ - çµæŸæ™‚é–“
document.getElementById('end-time').addEventListener('change', (e) => {
    const endTime = parseFloat(e.target.value);
    if (!isNaN(endTime) && endTime > currentTime && endTime <= totalDuration) {
        windowSize = endTime - currentTime;
        updateTimeInputs();
        updateView();
    } else {
        e.target.value = (currentTime + windowSize).toFixed(1);
    }
});

document.getElementById('end-time').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.target.blur();
    }
});

// æ›´æ–°æ™‚é–“è¼¸å…¥æ¡†é¡¯ç¤º
function updateTimeInputs() {
    document.getElementById('current-time').value = currentTime.toFixed(1);
    document.getElementById('end-time').value = (currentTime + windowSize).toFixed(1);
}

function updateView() {
    updateTimeInputs();
    // æ¸…é™¤å¿«å–ä»¥å¼·åˆ¶é‡æ–°è¼‰å…¥å¤§ç¯„åœæ•¸æ“š
    if (windowSize > CHUNK_SIZE) {
        Object.keys(signalCache).forEach(key => {
            const cache = signalCache[key];
            if (cache) cache.windowKey = null; // æ¨™è¨˜ç‚ºéæœŸ
        });
    }
    renderHypnogram();
    renderSignals();
}

document.addEventListener('DOMContentLoaded', () => {
    updateTimeInputs();
    updateView();
});
</script>
</body>
</html>
